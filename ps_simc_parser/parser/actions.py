"""
Action parser for converting SimC actions to PS Lua
"""
from typing import List, Dict, Any
from .apl import Action

class ActionParser:
    """Parser for converting SimC actions to PS Lua code"""
    
    def __init__(self):
        self.indent_level = 0
        self.indent_str = "    "

    def generate_lua(self, actions: List[Action]) -> str:
        """Generate PS Lua code from parsed actions"""
        lua_lines = []
        
        # Add header
        lua_lines.extend([
            "-- Generated by PS SimC Parser",
            "",
            "local Rotation = {",
            self.indent_str + "Name = 'Generated Rotation',",
            self.indent_str + "Profile = 'auto',",
            "}",
            ""
        ])
        
        # Generate main rotation function
        lua_lines.extend(self._generate_rotation_function(actions))
        
        # Add footer
        lua_lines.extend([
            "",
            "return Rotation"
        ])
        
        return "\n".join(lua_lines)
    
    def _generate_rotation_function(self, actions: List[Action]) -> List[str]:
        """Generate the main rotation function"""
        lines = [
            "function Rotation:Execute()",
            self.indent_str + "local Player = PS.Player",
            self.indent_str + "local Target = Player.Target",
            self.indent_str + "local Spells = PS.Spells",
            ""
        ]
        
        # Add each action
        for action in actions:
            lines.extend(self._convert_action(action))
            
        lines.append("end")
        return lines
    
    def _convert_action(self, action: Action) -> List[str]:
        """Convert a single action to Lua code"""
        lua_lines = []
        
        # Handle variable definitions
        if action.name == "variable":
            var_name = action.args.get("name")
            var_value = action.args.get("value")
            if var_name and var_value:
                lua_value = self._convert_condition(var_value)
                lua_lines.append(f"{self.indent_str}local {var_name} = {lua_value}")
            return lua_lines
        
        # Generate condition checks
        if action.conditions:
            conditions = " and ".join(self._convert_condition(c) for c in action.conditions)
            lua_lines.append(f"{self.indent_str}if {conditions} then")
            self.indent_level += 1
            
        # Generate action code
        action_lua = self._get_action_lua(action)
        lua_lines.append(f"{self.indent_str * (self.indent_level + 1)}{action_lua}")
        
        # Close condition block
        if action.conditions:
            self.indent_level -= 1
            lua_lines.append(f"{self.indent_str}end")
            
        return lua_lines
    
    def _convert_condition(self, condition: str) -> str:
        """Convert a SimC condition to PS Lua"""
        if not condition:
            return ""
            
        # Handle buff conditions
        if condition.startswith("buff.") and condition.endswith(".up"):
            spell_name = condition[5:-3]  # Remove buff. and .up
            return f"Player.Buff(Spells.{self._to_camel_case(spell_name)}).Exists"
            
        if condition.startswith("!buff.") and condition.endswith(".up"):
            spell_name = condition[6:-3]  # Remove !buff. and .up
            return f"not Player.Buff(Spells.{self._to_camel_case(spell_name)}).Exists"
            
        # Handle debuff conditions
        if condition.startswith("debuff.") and condition.endswith(".up"):
            spell_name = condition[7:-3]  # Remove debuff. and .up
            return f"Target.Debuff(Spells.{self._to_camel_case(spell_name)}).Exists"
            
        if condition.startswith("!debuff.") and condition.endswith(".up"):
            spell_name = condition[8:-3]  # Remove !debuff. and .up
            return f"not Target.Debuff(Spells.{self._to_camel_case(spell_name)}).Exists"
            
        # Handle talent conditions
        if condition.startswith("talent.") and condition.endswith(".enabled"):
            talent_name = condition[7:-8]  # Remove talent. and .enabled
            return f"Player.Talent(Spells.{self._to_camel_case(talent_name)}).Enabled"
            
        # Handle soul fragments conditions
        if condition.startswith("soul_fragments"):
            comparison = ""
            if ">=" in condition:
                value = condition.split(">=")[1]
                comparison = ">="
            elif "<=" in condition:
                value = condition.split("<=")[1]
                comparison = "<="
            elif ">" in condition:
                value = condition.split(">")[1]
                comparison = ">"
            elif "<" in condition:
                value = condition.split("<")[1]
                comparison = "<"
            elif "=" in condition:
                value = condition.split("=")[1]
                comparison = "=="
            if comparison:
                return f"Player.SoulFragments {comparison} {value}"
            return condition.replace("soul_fragments", "Player.SoulFragments")
            
        # Handle fury conditions
        if condition.startswith("fury"):
            comparison = ""
            if ">=" in condition:
                value = condition.split(">=")[1]
                comparison = ">="
            elif "<=" in condition:
                value = condition.split("<=")[1]
                comparison = "<="
            elif ">" in condition:
                value = condition.split(">")[1]
                comparison = ">"
            elif "<" in condition:
                value = condition.split("<")[1]
                comparison = "<"
            elif "=" in condition:
                value = condition.split("=")[1]
                comparison = "=="
            if comparison:
                return f"Player.Fury {comparison} {value}"
            
        # Handle incoming damage
        if condition.startswith("incoming_damage"):
            # Extract duration and comparison
            duration = ""
            value = ""
            comparison = ""
            
            if ">=" in condition:
                parts = condition.split(">=")
                duration = parts[0][16:parts[0].find("s")]
                value = parts[1]
                comparison = ">="
            elif "<=" in condition:
                parts = condition.split("<=")
                duration = parts[0][16:parts[0].find("s")]
                value = parts[1]
                comparison = "<="
            elif ">" in condition:
                parts = condition.split(">")
                duration = parts[0][16:parts[0].find("s")]
                value = parts[1]
                comparison = ">"
            elif "<" in condition:
                parts = condition.split("<")
                duration = parts[0][16:parts[0].find("s")]
                value = parts[1]
                comparison = "<"
            elif "=" in condition:
                parts = condition.split("=")
                duration = parts[0][16:parts[0].find("s")]
                value = parts[1]
                comparison = "=="
                
            return f"Player:IncomingDamage({duration}) {comparison} {value}"
            
        return condition
    
    def _get_action_lua(self, action: Action) -> str:
        """Get Lua code for a specific action"""
        spell_name = self._to_camel_case(action.name)
        
        # Handle ground targeted spells
        if action.args.get("target") == "ground":
            return f"if Player:Cast(Spells.{spell_name}, 'ground') then"
            
        return f"if Player:Cast(Spells.{spell_name}) then"
    
    def _to_camel_case(self, name: str) -> str:
        """Convert snake_case to CamelCase"""
        return "".join(word.capitalize() for word in name.split("_"))
