"""
Action parser module for PS SimC Parser
"""
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
import re

@dataclass
class Action:
    """Represents a parsed action"""
    action_type: str  # 'spell', 'variable', etc.
    name: str  # Name of spell or variable
    conditions: List[str] = field(default_factory=list)  # List of conditions
    args: Dict[str, Any] = field(default_factory=dict)  # Additional arguments
    line_number: int = 0  # Line number in source file

class ActionParser:
    """Parser for converting APL actions into PS actions"""
    
    def __init__(self):
        self.indent_level = 0
        self.indent_str = "    "
        
    def parse(self, apl_action, context) -> Optional[Action]:
        """Parse an APL action into a PS action"""
        # Skip empty actions
        if not apl_action.spell_name:
            return None
            
        # Create base action
        action = Action(
            action_type='spell' if apl_action.spell_name != 'variable' else 'variable',
            name=apl_action.spell_name,
            conditions=apl_action.conditions,
            args={},
            line_number=apl_action.line_number
        )
        
        # Add variable-specific args
        if action.action_type == 'variable':
            if apl_action.var_name:
                action.args['name'] = apl_action.var_name
            if apl_action.var_value:
                action.args['value'] = apl_action.var_value
            if apl_action.var_op:
                action.args['op'] = apl_action.var_op
                
        # Add target if specified
        if apl_action.target:
            action.args['target'] = apl_action.target
            
        # Add pool options if specified
        if apl_action.pool_for_next:
            action.args['pool_for_next'] = True
        if apl_action.pool_extra_amount is not None:
            action.args['pool_extra_amount'] = apl_action.pool_extra_amount
            
        # Add action list name if specified
        if apl_action.action_list_name:
            action.args['action_list'] = apl_action.action_list_name
            
        return action
        
    def generate_lua(self, actions: List[Action]) -> str:
        """Generate PS Lua code from parsed actions"""
        lua_lines = []
        
        # Add header
        lua_lines.extend([
            "-- Generated by PS SimC Parser",
            "",
            "local PS = ...",
            "local APL = PS.APL",
            "local Player = PS.Player",
            "local Target = Player.Target",
            "local Spell = PS.Spell",
            "local Item = PS.Item",
            "local Buff = PS.Buff",
            "local Debuff = PS.Debuff",
            "local Talent = PS.Talent",
            "local Enemies = Player.Enemies",
            "local Cache = {",
            "    variables = {},",
            "}",
            "",
            "-- Initialize variables",
            "function Cache:Get(key, default)",
            "    return self.variables[key] or default",
            "end",
            "",
            "function Cache:Set(key, value)",
            "    self.variables[key] = value",
            "end",
            "",
            "-- Action Lists",
            ""
        ])
        
        # Add action list functions
        action_lists = {}
        for action in actions:
            list_name = action.args.get('action_list', 'default')
            if list_name not in action_lists:
                action_lists[list_name] = []
            action_lists[list_name].append(action)
            
        # Generate code for each action list
        for list_name, list_actions in action_lists.items():
            # Add function header
            if list_name == 'default':
                lua_lines.append("function APL:Execute()")
            else:
                lua_lines.append(f"function APL:{list_name}()")
                
            # Add actions
            self.indent_level = 1
            for action in list_actions:
                lua_lines.extend(self._generate_action(action))
                
            # Add function footer
            self.indent_level = 0
            lua_lines.append("end")
            lua_lines.append("")
            
        # Add footer
        lua_lines.extend([
            "-- Return the APL",
            "return APL"
        ])
        
        return '\n'.join(lua_lines)
        
    def _generate_action(self, action: Action) -> List[str]:
        """Generate Lua code for a single action"""
        lua_lines = []
        
        # Add conditions if present
        if action.conditions:
            conditions = self._convert_conditions(action.conditions)
            lua_lines.append(f"{self.indent_str}if {conditions} then")
            self.indent_level += 1
            
        # Handle different action types
        if action.action_type == 'variable':
            lua_lines.extend(self._generate_variable(action))
        else:
            lua_lines.extend(self._generate_spell(action))
            
        # Close conditions if present
        if action.conditions:
            self.indent_level -= 1
            lua_lines.append(f"{self.indent_str}end")
            
        return lua_lines
        
    def _generate_variable(self, action: Action) -> List[str]:
        """Generate Lua code for a variable action"""
        lua_lines = []
        
        # Get variable details
        var_name = action.args.get('name', 'unnamed')
        var_value = action.args.get('value', '0')
        var_op = action.args.get('op', 'set')
        
        # Add variable operation
        if var_op == 'set':
            lua_lines.append(f"{self.indent_str}Cache:Set('{var_name}', {var_value})")
        elif var_op == 'add':
            lua_lines.append(f"{self.indent_str}Cache:Set('{var_name}', Cache:Get('{var_name}', 0) + {var_value})")
        elif var_op == 'sub':
            lua_lines.append(f"{self.indent_str}Cache:Set('{var_name}', Cache:Get('{var_name}', 0) - {var_value})")
        elif var_op == 'mul':
            lua_lines.append(f"{self.indent_str}Cache:Set('{var_name}', Cache:Get('{var_name}', 0) * {var_value})")
        elif var_op == 'div':
            lua_lines.append(f"{self.indent_str}Cache:Set('{var_name}', Cache:Get('{var_name}', 0) / {var_value})")
        elif var_op == 'min':
            lua_lines.append(f"{self.indent_str}Cache:Set('{var_name}', math.min(Cache:Get('{var_name}', 0), {var_value}))")
        elif var_op == 'max':
            lua_lines.append(f"{self.indent_str}Cache:Set('{var_name}', math.max(Cache:Get('{var_name}', 0), {var_value}))")
            
        return lua_lines
        
    def _generate_spell(self, action: Action) -> List[str]:
        """Generate Lua code for a spell action"""
        lua_lines = []
        
        # Add spell cast
        spell_name = self._format_spell_name(action.name)
        
        # Handle special actions
        if spell_name == 'SnapshotStats':
            lua_lines.append(f"{self.indent_str}-- Snapshot stats")
        elif spell_name == 'Potion':
            lua_lines.append(f"{self.indent_str}if Item.Potion:IsReady() then")
            lua_lines.append(f"{self.indent_str}    Item.Potion:Use()")
            lua_lines.append(f"{self.indent_str}end")
        elif spell_name == 'Flask':
            lua_lines.append(f"{self.indent_str}if Item.Flask:IsReady() then")
            lua_lines.append(f"{self.indent_str}    Item.Flask:Use()")
            lua_lines.append(f"{self.indent_str}end")
        elif spell_name == 'Food':
            lua_lines.append(f"{self.indent_str}if Item.Food:IsReady() then")
            lua_lines.append(f"{self.indent_str}    Item.Food:Use()")
            lua_lines.append(f"{self.indent_str}end")
        elif spell_name == 'Augmentation':
            lua_lines.append(f"{self.indent_str}if Item.Augmentation:IsReady() then")
            lua_lines.append(f"{self.indent_str}    Item.Augmentation:Use()")
            lua_lines.append(f"{self.indent_str}end")
        elif spell_name == 'UseItem':
            lua_lines.append(f"{self.indent_str}if Item.Trinket1:IsReady() then")
            lua_lines.append(f"{self.indent_str}    Item.Trinket1:Use()")
            lua_lines.append(f"{self.indent_str}end")
        elif spell_name == 'PoolResource':
            lua_lines.append(f"{self.indent_str}-- Pool resource")
        elif spell_name == 'CallActionList':
            list_name = action.args.get('action_list', 'default')
            lua_lines.append(f"{self.indent_str}APL:{list_name}()")
        elif spell_name == 'RunActionList':
            list_name = action.args.get('action_list', 'default')
            lua_lines.append(f"{self.indent_str}return APL:{list_name}()")
        elif spell_name == 'Wait':
            lua_lines.append(f"{self.indent_str}-- Wait")
        elif spell_name == 'InvokeExternalBuff':
            lua_lines.append(f"{self.indent_str}-- Invoke external buff")
        elif spell_name == 'FelDesolation':
            lua_lines.append(f"{self.indent_str}if Spell.FelDevastation:IsReady() then")
            lua_lines.append(f"{self.indent_str}    Spell.FelDevastation:Cast()")
            lua_lines.append(f"{self.indent_str}    return true")
            lua_lines.append(f"{self.indent_str}end")
        elif spell_name == 'SigilOfDoom':
            lua_lines.append(f"{self.indent_str}if Spell.SigilOfFlame:IsReady() then")
            lua_lines.append(f"{self.indent_str}    Spell.SigilOfFlame:Cast()")
            lua_lines.append(f"{self.indent_str}    return true")
            lua_lines.append(f"{self.indent_str}end")
        else:
            # Regular spell cast
            lua_lines.append(f"{self.indent_str}if Spell.{spell_name}:IsReady() then")
            lua_lines.append(f"{self.indent_str}    Spell.{spell_name}:Cast()")
            lua_lines.append(f"{self.indent_str}    return true")
            lua_lines.append(f"{self.indent_str}end")
            
        return lua_lines
        
    def _format_spell_name(self, name: str) -> str:
        """Format a spell name for Lua code"""
        # Remove underscores and capitalize first letter of each word
        words = name.split('_')
        return ''.join(word.title() for word in words)
        
    def _convert_conditions(self, conditions: List[str]) -> str:
        """Convert SimC conditions to Lua conditions"""
        converted = []
        for condition in conditions:
            # Convert SimC operators to Lua
            condition = condition.replace('&&', ' and ')
            condition = condition.replace('||', ' or ')
            condition = condition.replace('!', 'not ')
            condition = condition.replace('==', ' == ')
            condition = condition.replace('>=', ' >= ')
            condition = condition.replace('<=', ' <= ')
            condition = condition.replace('!=', ' ~= ')
            condition = condition.replace('>', ' > ')
            condition = condition.replace('<', ' < ')
            
            # Convert variable references
            condition = re.sub(r'variable\.(\w+)', r"Cache:Get('\1')", condition)
            
            # Convert buff/debuff references
            condition = re.sub(r'buff\.(\w+)\.(\w+)', lambda m: f'Buff.{self._format_spell_name(m.group(1))}.{m.group(2)}', condition)
            condition = re.sub(r'debuff\.(\w+)\.(\w+)', lambda m: f'Debuff.{self._format_spell_name(m.group(1))}.{m.group(2)}', condition)
            
            # Convert talent references
            condition = re.sub(r'talent\.(\w+)', lambda m: f'Talent.{self._format_spell_name(m.group(1))}', condition)
            
            # Convert spell references
            condition = re.sub(r'spell\.(\w+)', lambda m: f'Spell.{self._format_spell_name(m.group(1))}', condition)
            
            # Convert cooldown references
            condition = re.sub(r'cooldown\.(\w+)\.(\w+)', lambda m: f'Spell.{self._format_spell_name(m.group(1))}.{m.group(2)}', condition)
            
            # Convert action references
            condition = re.sub(r'action\.(\w+)\.(\w+)', lambda m: f'Spell.{self._format_spell_name(m.group(1))}.{m.group(2)}', condition)
            
            # Convert dot references
            condition = re.sub(r'dot\.(\w+)\.(\w+)', lambda m: f'Debuff.{self._format_spell_name(m.group(1))}.{m.group(2)}', condition)
            
            # Convert active_dot references
            condition = re.sub(r'active_dot\.(\w+)', lambda m: f'Debuff.{self._format_spell_name(m.group(1))}.Active', condition)
            
            # Convert charges references
            condition = re.sub(r'charges_fractional', 'ChargesFractional', condition)
            condition = re.sub(r'max_charges', 'MaxCharges', condition)
            
            # Convert prev_gcd references
            condition = re.sub(r'prev_gcd\.(\d+)\.(\w+)', lambda m: f'Player:PrevGCD({m.group(1)}, Spell.{self._format_spell_name(m.group(2))})', condition)
            
            # Convert fury references
            condition = re.sub(r'\bfury\b', 'Player.Fury', condition)
            
            # Convert soul_fragments references
            condition = re.sub(r'soul_fragments\.(\w+)', r'Player.SoulFragments.\1', condition)
            condition = re.sub(r'\bsoul_fragments\b', 'Player.SoulFragments.Count', condition)
            
            # Convert hero_tree references
            condition = re.sub(r'hero_tree\.(\w+)', lambda m: f'Talent.{self._format_spell_name(m.group(1))}', condition)
            
            # Convert target references
            condition = re.sub(r'target\.debuff\.(\w+)\.(\w+)', lambda m: f'Target.Debuff.{self._format_spell_name(m.group(1))}.{m.group(2)}', condition)
            condition = re.sub(r'target\.buff\.(\w+)\.(\w+)', lambda m: f'Target.Buff.{self._format_spell_name(m.group(1))}.{m.group(2)}', condition)
            condition = re.sub(r'target\.time_to_die', 'Target.TimeToDie', condition)
            
            # Convert spell_targets references
            condition = re.sub(r'spell_targets\.(\w+)', lambda m: f'Enemies:GetCount(Spell.{self._format_spell_name(m.group(1))})', condition)
            
            # Convert gcd references
            condition = re.sub(r'\bgcd\.(\w+)\b', r'Player.GCD.\1', condition)
            condition = re.sub(r'\bgcd\b', 'Player.GCD', condition)
            
            # Convert fight_remains references
            condition = re.sub(r'fight_remains', 'Target.TimeToDie', condition)
            
            # Convert execute_time references
            condition = re.sub(r'execute_time', 'ExecuteTime', condition)
            
            # Handle parentheses
            condition = re.sub(r'\(([^()]*)\)', lambda m: f'({m.group(1)})', condition)
            
            converted.append(condition.strip())
            
        return ' and '.join(converted)
