"""
Lua code templates for PS SimC Parser
"""
from typing import Dict, Any, List
from datetime import datetime

class LuaTemplate:
    """Base class for Lua code templates"""
    
    def render(self, context: dict) -> str:
        """Render the template with the given context"""
        lua_code = []

        # Add header
        lua_code.extend([
            "-- Generated by PS SimC Parser",
            "",
            "local PS = ...",
            "local Spell = PS.Spell",
            "local Player = PS.Player",
            "local Target = Player.Target",
            "local Enemies = Player.Enemies",
            "local Cache = {}",
            "",
            "-- Initialize cache",
            "function Cache:Get(key, default)",
            "    return self[key] or default",
            "end",
            "",
            "function Cache:Set(key, value)",
            "    self[key] = value",
            "end",
            ""
        ])

        # Add metadata
        metadata = context.get('metadata', {})
        
        # Add action lists
        action_lists = context.get('action_lists', {})
        
        # Add Precombat function with precombat actions
        lua_code.extend([
            "function Precombat()",
            "    -- Precombat actions"
        ])
        if 'precombat' in action_lists:
            lua_code.append(action_lists['precombat'])
        lua_code.extend([
            "end",
            ""
        ])

        # Add Default function with default actions
        lua_code.extend([
            "function Default()",
            "    -- Default actions"
        ])
        if 'default' in action_lists:
            lua_code.append(action_lists['default'])
        lua_code.extend([
            "end",
            ""
        ])

        # Add Rotation function with main rotation
        lua_code.extend([
            "function Rotation()",
            "    -- Check if we have a valid target",
            "    if not Target:Exists() or Target:IsDead() then",
            "        return",
            "    end",
            "",
            "    -- Check resources",
            "    local fury = Player.Fury",
            "    local fury_deficit = Player.Fury.Deficit",
            "",
            "    -- Check defensive abilities",
            "    if Spell.DemonSpikes:IsReady() then",
            "        return Cast(Spell.DemonSpikes)",
            "    end",
            "",
            "    if Spell.FieryBrand:IsReady() then",
            "        return Cast(Spell.FieryBrand)",
            "    end",
            "",
            "    if Spell.Metamorphosis:IsReady() then",
            "        return Cast(Spell.Metamorphosis)",
            "    end",
            "",
            "    -- Check AOE abilities",
            "    if Spell.ImmolationAura:IsReady() then",
            "        return Cast(Spell.ImmolationAura)",
            "    end",
            "",
            "    if Spell.SigilOfFlame:IsReady() then",
            "        return Cast(Spell.SigilOfFlame, 'ground')",
            "    end",
            "",
            "    if Spell.SpiritBomb:IsReady() and Player.SoulFragments >= 4 then",
            "        return Cast(Spell.SpiritBomb)",
            "    end",
            "",
            "    -- Run action lists",
            "    Default()",
            "end",
            "",
            "return Rotation"
        ])

        return '\n'.join(lua_code)

    @staticmethod
    def format_imports(imports: List[str]) -> str:
        """Format PS API imports"""
        import_lines = []
        for imp in imports:
            import_lines.append(f"local {imp} = PS.{imp}")
        return "\n".join(import_lines)

    @staticmethod
    def format_variable_declaration(name: str, value: str) -> str:
        """Format a variable declaration"""
        return f"local {name} = {value}"

    # Core templates
    @staticmethod
    def format_header() -> str:
        """Format the header with imports and cache setup"""
        return '''-- Generated by PS SimC Parser
local PS = ...
local Spell = PS.Spell
local Player = PS.Player
local Target = Player.Target
local Enemies = Player.Enemies
local Cache = {}

-- Initialize cache
function Cache:Get(key, default)
    return self[key] or default
end

function Cache:Set(key, value)
    self[key] = value
end'''

    @staticmethod
    def format_rotation_table(name: str, profile: str, class_name: str, spec: str, role: str = 'dps', action_lists: str = "") -> str:
        """Format the rotation table"""
        return f'''
-- Define Rotation table
local Rotation = {{
    Name = "{name}",
    Profile = "{profile}",
    Class = "{class_name}",
    Spec = "{spec}",
    Role = "{role}",
    Cache = Cache,
}}

function Rotation:Execute()
    -- Check if we have a valid target
    if not Target:Exists() or Target:IsDead() then
        return
    end
    
    -- Update state
    self.CombatTime = Combat:GetTime()
    self.TargetGUID = Target:GUID()
    
    -- Update caches
    if self.LastTarget ~= self.TargetGUID then
        self.Cache:Reset()
        self.LastTarget = self.TargetGUID
    end
    
    -- Check if we should stop
    if Player:IsCasting() or Player:IsChanneling() or Player:IsMoving() then return end
    
    -- Check if we're in combat
    if not Combat:Exists() then return end
    
    -- Run action lists
    {action_lists}
end

return Rotation'''

    @staticmethod
    def format_utility_functions() -> str:
        """Format utility functions"""
        return """
-- Utility functions
function Rotation:ShouldStop()
    return Player:IsCasting() or Player:IsChanneling() or Player:IsMoving()
end

function Rotation:CanUseGCD()
    return not Player:PrevGCD(1, Spell.GlobalCooldown)
end

function Rotation:CanUseOffGCD()
    return not Player:PrevOffGCD(1, Spell.GlobalCooldown)
end

function Rotation:UpdateState()
    self.CombatTime = Combat:GetTime()
    self.TargetGUID = Target:GUID()
    
    -- Update caches
    if self.LastTarget ~= self.TargetGUID then
        self.Cache:Reset()
        self.LastTarget = self.TargetGUID
    end
end

function Rotation:ShouldUseDefensive()
    local hp = Player:HealthPercent()
    return hp <= self.Settings.MinimumDefensivePercent
end

function Rotation:ShouldUseHealing()
    local hp = Player:HealthPercent()
    return hp <= self.Settings.MinimumHealingPercent
end

function Rotation:ShouldInterrupt()
    if not self.Settings.UseInterrupts then return false end
    if not Target:IsInterruptible() then return false end
    
    local castTimeRemaining = Target:CastTimeRemaining()
    local interruptPercent = (castTimeRemaining / Target:CastDuration()) * 100
    
    return interruptPercent >= self.Settings.MinimumInterruptPercent
end

function Rotation:GetEnemiesInRange(range)
    return math.min(Enemies:GetCount(range), self.Settings.MaxEnemies)
end

function Rotation:IsAOE()
    return self:GetEnemiesInRange(8) >= self.Settings.MinEnemies
end

function Rotation:IsCleave()
    return self:GetEnemiesInRange(8) >= 2
end

function Rotation:UseItems()
    if not self.Settings.UseTrinkets then return end
    
    -- Use trinkets
    if Item.Trinket1:IsReady() and self:CanUseOffGCD() then
        return Cast(Item.Trinket1)
    end
    
    if Item.Trinket2:IsReady() and self:CanUseOffGCD() then
        return Cast(Item.Trinket2)
    end
end

function Rotation:UseDefensives()
    if not self.Settings.UseDefensives then return end
    if not self:ShouldUseDefensive() then return end
    
    -- Implement defensive usage here
end

function Rotation:UseInterrupts()
    if not self:ShouldInterrupt() then return end
    
    -- Implement interrupts here
end
"""

    @staticmethod
    def format_execute_function() -> str:
        """Format the main execute function"""
        return """
function Rotation:Execute()
    -- Update state
    self:UpdateState()
    
    -- Check if we should stop
    if self:ShouldStop() then return end
    
    -- Check if we're in combat
    if not Combat:Exists() then return end
    
    -- Run action lists
    {action_lists}
end

return Rotation
"""

    # Action templates
    @staticmethod
    def format_spell_cast(spell_name: str, conditions: list = None, comment: str = None) -> str:
        """Format a spell cast with conditions"""
        conditions = conditions or []
        condition_str = " and ".join(conditions) if conditions else "true"
        comment = f"-- {comment}\n    " if comment else ""
        
        return f"""
    {comment}if Spell.{spell_name}:IsReady() and {condition_str} then
        return Cast(Spell.{spell_name})
    end
"""

    @staticmethod
    def format_item_use(item_name: str, conditions: list = None) -> str:
        """Format an item use"""
        conditions = conditions or []
        condition_str = " and ".join(conditions) if conditions else "true"
        
        return f"""
    if Item.{item_name}:IsReady() and {condition_str} then
        return Use(Item.{item_name})
    end
"""

    @staticmethod
    def format_variable_update(name: str, value: str, conditions: list = None) -> str:
        """Format a variable update"""
        conditions = conditions or []
        if conditions:
            condition_str = " and ".join(conditions)
            return f"""
    if {condition_str} then
        Cache:Set("{name}", {value})
    end
"""
        return f"""
    Cache:Set("{name}", {value})
"""

    # Condition templates
    @staticmethod
    def format_buff_check(buff_name: str, stacks: int = None) -> str:
        """Format a buff check"""
        if stacks:
            return f"Player.Buff({buff_name}):Stack() >= {stacks}"
        return f"Player.Buff({buff_name}):Exists()"

    @staticmethod
    def format_debuff_check(debuff_name: str, stacks: int = None) -> str:
        """Format a debuff check"""
        if stacks:
            return f"Target.Debuff({debuff_name}):Stack() >= {stacks}"
        return f"Target.Debuff({debuff_name}):Exists()"

    @staticmethod
    def format_resource_check(resource: str, operator: str, value: int) -> str:
        """Format a resource check"""
        return f"Player.{resource} {operator} {value}"

    @staticmethod
    def format_cooldown_check(spell_name: str) -> str:
        """Format a cooldown check"""
        return f"Spell.{spell_name}:CooldownUp()"

    @staticmethod
    def format_charges_check(spell_name: str, operator: str, value: float) -> str:
        """Format a charges check"""
        return f"Spell.{spell_name}:Charges() {operator} {value}"

    @staticmethod
    def format_enemies_check(range: int, operator: str, value: int) -> str:
        """Format an enemies check"""
        return f"self:GetEnemiesInRange({range}) {operator} {value}"

    @staticmethod
    def format_health_check(unit: str, operator: str, value: int) -> str:
        """Format a health check"""
        return f"{unit}:HealthPercent() {operator} {value}"

    @staticmethod
    def format_time_check(check_type: str, operator: str, value: float) -> str:
        """Format a time check"""
        if check_type == "combat":
            return f"Combat:GetTime() {operator} {value}"
        elif check_type == "target":
            return f"Target:TimeToDie() {operator} {value}"
        return f"self.{check_type} {operator} {value}"

    # Function templates
    @staticmethod
    def format_function(name: str, params: list = None, body: str = "") -> str:
        """Format a function definition"""
        params = params or []
        param_str = ", ".join(params)
        return f"""
function {name}({param_str})
    {body}
end
"""

    @staticmethod
    def format_action_list(name: str, actions: List[str]) -> str:
        """Format an action list"""
        actions_str = "\n".join(actions)
        return f"""
function Rotation:{name}()
    {actions_str}
end
"""

    @staticmethod
    def format_precombat() -> str:
        """Format precombat actions"""
        return """
function Rotation:Precombat()
    -- Handle precombat actions
    if Player:AffectingCombat() then return end
    
    -- Buffs and preparations
    {body}
end
"""

    @staticmethod
    def format_return() -> str:
        """Format the rotation return statement"""
        return "\nreturn Rotation"

    def render_imports(self, imports: List[str]) -> str:
        return f"local {', '.join(imports)} = PS.API\n" 